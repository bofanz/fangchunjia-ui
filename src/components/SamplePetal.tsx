/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
// @ts-nocheck
import React, { useRef, useMemo, useEffect } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

export function Model({ setHoveredIndex }: { setHoveredIndex: Function }) {
  const { nodes, materials } = useGLTF('/p0.glb');
  const groupRef = useRef();
  const meshRefs = useRef([]);
  const elapsedRef = useRef(0);

  // Generate unique random values for each mesh (9 meshes total)
  const meshData = useMemo(() => {
    const meshCount = 8;
    const randoms = [];
    const basePositions = [
      [-0.296, 1.434, -1.063],
      [-1.201, 2.105, -1.069],
      [1.366, 1.79, -1.046],
      [1.471, 1.246, -1.208],
      [-1.696, 2.523, -1.012],
      [-0.96, 0.685, -1.098],
      [-0.045, 0.395, -0.908],
      [0.278, 0.321, -0.985],
    ];
    const baseRotations = [
      [-2.616, -1.065, 1.699],
      [-1.524, -1.336, Math.PI],
      [2.385, -0.903, 0.241],
      [-1.421, 0.738, -2.998],
      [2.146, -0.245, -0.17],
      [2.341, 0.174, -0.141],
      [1.48, -0.059, -3.005],
      [0.293, -1.201, -0.736],
    ];

    for (let i = 0; i < meshCount; i++) {
      randoms.push({
        // Position randoms
        x: Math.random(),
        y: Math.random(),
        z: Math.random(),
        w: Math.random(),
        // Rotation randoms (additional set for independent rotation motion)
        rx: Math.random(),
        ry: Math.random(),
        rz: Math.random(),
        rw: Math.random(),
        // Rotation speed multipliers (some leaves rotate faster than others)
        speedX: 0.3 + Math.random() * 0.7,
        speedY: 0.3 + Math.random() * 0.7,
        speedZ: 0.3 + Math.random() * 0.7,
      });
    }

    return { randoms, basePositions, baseRotations };
  }, []);

  // Animation loop - applies floating effect to each mesh
  useFrame((state, delta) => {
    // Update elapsed time (speed multiplier can be adjusted)
    elapsedRef.current += delta * 0.5; // 0.5 is the speed - adjust as needed
    const t = elapsedRef.current;

    // Animate each mesh
    meshRefs.current.forEach((mesh, i) => {
      if (!mesh) return;

      const basePos = meshData.basePositions[i];
      const baseRot = meshData.baseRotations[i];
      const random = meshData.randoms[i];

      // Calculate animated position offset using sine waves
      const offsetX =
        Math.sin(t * random.z + 6.28318 * random.w) * (0.05 + 0.15 * random.x);
      const offsetY =
        Math.sin(t * random.y + 6.28318 * random.x) * (0.05 + 0.15 * random.w);
      const offsetZ =
        Math.sin(t * random.w + 6.28318 * random.y) * (0.05 + 0.15 * random.z);

      // Apply new position (base + offset)
      mesh.position.set(
        basePos[0] + offsetX,
        basePos[1] + offsetY,
        basePos[2] + offsetZ,
      );

      // Calculate animated rotation offset using sine waves
      // Leaves gently rock and twist in the breeze
      const rotOffsetX =
        Math.sin(t * random.rx * random.speedX + 6.28318 * random.rw) *
        (0.1 + 0.3 * random.rx); // Gentle rocking on X axis
      const rotOffsetY =
        Math.sin(t * random.ry * random.speedY + 6.28318 * random.rx) *
        (0.15 + 0.4 * random.ry); // More twist on Y axis
      const rotOffsetZ =
        Math.sin(t * random.rz * random.speedZ + 6.28318 * random.ry) *
        (0.1 + 0.3 * random.rz); // Gentle rocking on Z axis

      // Apply new rotation (base + offset)
      mesh.rotation.set(
        baseRot[0] + rotOffsetX,
        baseRot[1] + rotOffsetY,
        baseRot[2] + rotOffsetZ,
      );
    });
  });

  useEffect(() => {
    meshRefs.current.forEach((mesh) => {
      if (mesh && mesh.geometry) {
        mesh.geometry.computeVertexNormals();
      }
    });
  }, [nodes]);

  return (
    <group
      ref={groupRef}
      // {...props}
      dispose={null}
      scale={6}
      position={[0, -8, 0]}
    >
      <mesh
        ref={(el) => (meshRefs.current[0] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Plane001.geometry}
        material={materials['Material.001']}
        scale={0.936}
        onPointerEnter={() => setHoveredIndex(2)}
        onPointerLeave={() => setHoveredIndex(null)}
      >
        <meshPhysicalMaterial
          color={'#bebee5'}
          metalness={0.3}
          roughness={0.15}
          clearcoat={1.0}
          clearcoatRoughness={0.1}
          envMapIntensity={2.5}
          reflectivity={1.0}
          side={THREE.DoubleSide}
        />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[1] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Plane002.geometry}
        material={materials['Material.001']}
      >
        <meshPhysicalMaterial
          color={'#bebee5'}
          metalness={0.3}
          roughness={0.15}
          clearcoat={1.0}
          clearcoatRoughness={0.1}
          envMapIntensity={2.5}
          reflectivity={1.0}
          side={THREE.DoubleSide}
        />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[2] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Plane003.geometry}
        material={materials['Material.001']}
        scale={[0.554, 0.967, 0.98]}
      >
        <meshPhysicalMaterial
          color={'#bebee5'}
          metalness={0.3}
          roughness={0.15}
          clearcoat={1.0}
          clearcoatRoughness={0.1}
          envMapIntensity={2.5}
          reflectivity={1.0}
          side={THREE.DoubleSide}
        />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[3] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Plane004.geometry}
        material={materials['Material.001']}
        scale={[1.206, 1.049, 0.911]}
      >
        <meshPhysicalMaterial
          color={'#bebee5'}
          metalness={0.3}
          roughness={0.15}
          clearcoat={1.0}
          clearcoatRoughness={0.1}
          envMapIntensity={2.5}
          reflectivity={1.0}
          side={THREE.DoubleSide}
        />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[4] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Plane005.geometry}
        material={materials['Material.001']}
        scale={[0.55, 0.83, 0.579]}
      >
        <meshPhysicalMaterial
          color={'#bebee5'}
          metalness={0.3}
          roughness={0.15}
          clearcoat={1.0}
          clearcoatRoughness={0.1}
          envMapIntensity={2.5}
          reflectivity={1.0}
          side={THREE.DoubleSide}
        />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[5] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Plane006.geometry}
        material={materials['Material.001']}
        scale={[0.673, 0.619, 0.711]}
      >
        <meshPhysicalMaterial
          color={'#bebee5'}
          metalness={0.3}
          roughness={0.15}
          clearcoat={1.0}
          clearcoatRoughness={0.1}
          envMapIntensity={2.5}
          reflectivity={1.0}
          side={THREE.DoubleSide}
        />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[6] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Plane007.geometry}
        material={materials['Material.001']}
        scale={[0.913, 0.984, 1]}
      >
        <meshPhysicalMaterial
          color={'#bebee5'}
          metalness={0.3}
          roughness={0.15}
          clearcoat={1.0}
          clearcoatRoughness={0.1}
          envMapIntensity={2.5}
          reflectivity={1.0}
          side={THREE.DoubleSide}
        />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[7] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Plane008.geometry}
        material={materials['Material.001']}
        scale={[-0.508, -0.236, -0.255]}
      >
        <meshPhysicalMaterial
          color={'#bebee5'}
          metalness={0.3}
          roughness={0.15}
          clearcoat={1.0}
          clearcoatRoughness={0.1}
          envMapIntensity={2.5}
          reflectivity={1.0}
          side={THREE.DoubleSide}
        />
      </mesh>
    </group>
  );
}

useGLTF.preload('/p0.glb');
