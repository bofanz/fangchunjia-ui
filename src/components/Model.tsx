/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import { useEffect, useMemo, useRef } from 'react';
import { useGLTF } from '@react-three/drei';
import type { GLTF } from 'three-stdlib';
import { useFrame } from '@react-three/fiber';

type GLTFResult = GLTF & {
  nodes: {
    Sphere: THREE.Mesh;
    Sphere001: THREE.Mesh;
    Sphere002: THREE.Mesh;
    Sphere003: THREE.Mesh;
    Sphere004: THREE.Mesh;
    Sphere005: THREE.Mesh;
    Sphere006: THREE.Mesh;
    Sphere007: THREE.Mesh;
    Sphere008: THREE.Mesh;
    Sphere009: THREE.Mesh;
    Sphere010: THREE.Mesh;
    Sphere011: THREE.Mesh;
    Sphere012: THREE.Mesh;
    Sphere013: THREE.Mesh;
    Sphere014: THREE.Mesh;
    Sphere015: THREE.Mesh;
    Sphere016: THREE.Mesh;
    Sphere017: THREE.Mesh;
  };
  materials: {
    ['Material.001']: THREE.MeshStandardMaterial;
  };
};

function BluebellMaterial() {
  return (
    <meshPhysicalMaterial
      color={'#bebee5'}
      metalness={0.3}
      roughness={0.15}
      clearcoat={1.0}
      clearcoatRoughness={0.1}
      envMapIntensity={2.5}
      reflectivity={1.0}
      side={THREE.DoubleSide}
    />
  );
}

export function Model({ setHoveredIndex }: { setHoveredIndex: Function }) {
  const { nodes } = useGLTF('/home.glb') as unknown as GLTFResult;
  const groupRef = useRef<THREE.Group | undefined>(undefined);
  const meshRefs = useRef<(THREE.Mesh | null)[]>([]);
  const elapsedRef = useRef(0);

  // Generate unique random values for each mesh (9 meshes total)
  const meshData = useMemo(() => {
    const meshCount = 18;
    const randoms = [];
    const basePositions = [
      [0.045, 0, -0.96],
      [0.48, 0.691, -0.822],
      [1.089, 0, -0.96],
      [1.129, 1.129, -0.96],
      [1.473, 1.603, -0.96],
      [-1.304, 0.401, -0.96],
      [-0.672, 0.085, -0.96],
      [0.045, 0, -0.96],
      [-0.768, 0.627, -0.96],
      [-0.386, 1.347, -0.908],
      [1.484, 1.217, -0.933],
      [-1.208, 2.111, -0.96],
      [-1.706, 2.488, -0.974],
      [-1.614, 0.965, -0.954],
      [-1.801, 0.119, -0.96],
      [1.834, 0.606, -0.963],
      [-1.731, 0.107, -0.955],
      [-1.784, 0.133, -1.014],
    ];

    for (let i = 0; i < meshCount; i++) {
      randoms.push({
        // Position randoms
        x: Math.random(),
        y: Math.random(),
        z: Math.random(),
        w: Math.random(),
        // Rotation randoms (additional set for independent rotation motion)
        rx: Math.random(),
        ry: Math.random(),
        rz: Math.random(),
        rw: Math.random(),
        // Rotation speed multipliers (some leaves rotate faster than others)
        speedX: 0.3 + Math.random() * 0.7,
        speedY: 0.3 + Math.random() * 0.7,
        speedZ: 0.3 + Math.random() * 0.7,
      });
    }

    return { randoms, basePositions };
  }, []);

  // Animation loop - applies floating effect to each mesh
  useFrame((state, delta) => {
    // Update elapsed time (speed multiplier can be adjusted)
    elapsedRef.current += delta * 0.5; // 0.5 is the speed - adjust as needed
    const t = elapsedRef.current;

    // Animate each mesh
    meshRefs.current.forEach((mesh, i) => {
      if (!mesh) return;

      const basePos = meshData.basePositions[i];
      const random = meshData.randoms[i];

      // Calculate animated position offset using sine waves
      const offsetX =
        Math.sin(t * random.z + 6.28318 * random.w) * (0.05 + 0.15 * random.x);
      const offsetY =
        Math.sin(t * random.y + 6.28318 * random.x) * (0.05 + 0.15 * random.w);
      const offsetZ =
        Math.sin(t * random.w + 6.28318 * random.y) * (0.05 + 0.15 * random.z);

      // Apply new position (base + offset)
      mesh.position.set(
        basePos[0] + offsetX,
        basePos[1] + offsetY,
        basePos[2] + offsetZ,
      );
    });
  });

  useEffect(() => {
    meshRefs.current.forEach((mesh) => {
      if (mesh && mesh.geometry) {
        mesh.geometry.computeVertexNormals();
      }
    });
  }, [nodes]);
  return (
    <group dispose={null} scale={6} position={[0, -6, 0]} ref={groupRef}>
      <mesh
        ref={(el) => (meshRefs.current[0] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere.geometry}
        position={[0.045, 0, -0.96]}
        scale={0.082}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[1] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere001.geometry}
        position={[0.48, 0.691, -0.822]}
        scale={0.053}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[2] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere002.geometry}
        position={[1.089, 0, -0.96]}
        scale={0.067}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[3] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere003.geometry}
        position={[1.129, 1.129, -0.96]}
        scale={0.067}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[4] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere004.geometry}
        position={[1.473, 1.603, -0.96]}
        scale={0.067}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[5] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere005.geometry}
        position={[-1.304, 0.401, -0.96]}
        scale={0.035}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[6] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere006.geometry}
        position={[-0.672, 0.085, -0.96]}
        scale={0.035}
        onPointerEnter={() => setHoveredIndex(2)}
        onPointerLeave={() => setHoveredIndex(null)}
      >
        {/* <BluebellMaterial /> */}
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[7] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere007.geometry}
        position={[0.045, 0, -0.96]}
        scale={0.082}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[8] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere008.geometry}
        position={[-0.768, 0.627, -0.96]}
        scale={0.09}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[9] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere009.geometry}
        position={[-0.386, 1.347, -0.908]}
        scale={0.09}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[10] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere010.geometry}
        position={[1.484, 1.217, -0.933]}
        scale={0.067}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[11] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere011.geometry}
        position={[-1.208, 2.111, -0.96]}
        scale={0.067}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[12] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere012.geometry}
        position={[-1.706, 2.488, -0.974]}
        scale={0.041}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[13] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere013.geometry}
        position={[-1.614, 0.965, -0.954]}
        scale={0.053}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[14] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere014.geometry}
        position={[-1.801, 0.119, -0.96]}
        scale={0.035}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[15] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere015.geometry}
        position={[1.834, 0.606, -0.963]}
        scale={0.019}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[16] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere016.geometry}
        position={[-1.731, 0.107, -0.955]}
        scale={0.023}
      >
        <BluebellMaterial />
      </mesh>
      <mesh
        ref={(el) => (meshRefs.current[17] = el)}
        castShadow
        receiveShadow
        geometry={nodes.Sphere017.geometry}
        position={[-1.784, 0.133, -1.014]}
        scale={0.017}
      >
        <BluebellMaterial />
      </mesh>
    </group>
  );
}

useGLTF.preload('/home.glb');
